#+TITLE: Git Tutorial
#+DATE: 2019-07-01 Mon
#+AUTHOR: Dr Yufeng Lin
#+EMAIL: yourslinyf@gmail.com
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:t p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:t todo:t |:t
#+CREATOR: Emacs 25.2.2 (Org mode 8.2.10)
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+DRAWERS: ANSWER
#+STARTUP: content

* Primer
** What is Version Control
Version control systems are a category of software tools that help a software team manage changes to source code over time. Version control software keeps track of every modification to the code in a special kind of database. If a mistake is made, developers can turn back the clock and compare earlier versions of the code to help fix the mistake while minimizing disruption to all team members.

For almost all software projects, the source code is like the crown jewels - a precious asset whose value must be protected. For most software teams, the source code is a repository of the invaluable knowledge and understanding about the problem domain that the developers have collected and refined through careful effort. Version control protects source code from both catastrophe and the casual degradation of human error and unintended consequences.

Software developers working in teams are continually writing new source code and changing existing source code. The code for a project, app or software component is typically organized in a folder structure or "file tree". One developer on the team may be working on a new feature while another developer fixes an unrelated bug by changing code, each developer may make their changes in several parts of the file tree.

Version control helps teams solve these kinds of problems, tracking every individual change by each contributor and helping prevent concurrent work from conflicting. Changes made in one part of the software can be incompatible with those made by another developer working at the same time. This problem should be discovered and solved in an orderly manner without blocking the work of the rest of the team. Further, in all software development, any change can introduce new bugs on its own and new software can't be trusted until it's tested. So testing and development proceed together until a new version is ready.

Good version control software supports a developer's preferred workflow without imposing one particular way of working. Ideally it also works on any platform, rather than dictate what operating system or tool chain developers must use. Great version control systems facilitate a smooth and continuous flow of changes to the code rather than the frustrating and clumsy mechanism of file locking - giving the green light to one developer at the expense of blocking the progress of others.

Software teams that do not use any form of version control often run into problems like not knowing which changes that have been made are available to users or the creation of incompatible changes between two unrelated pieces of work that must then be painstakingly untangled and reworked. If you're a developer who has never used version control you may have added versions to your files, perhaps with suffixes like "final" or "latest" and then had to later deal with a new final version. Perhaps you've commented out code blocks because you want to disable certain functionality without deleting the code, fearing that there may be a use for it later. Version control is a way out of these problems.

Version control software is an essential part of the every-day of the modern software team's professional practices. Individual software developers who are accustomed to working with a capable version control system in their teams typically recognize the incredible value version control also gives them even on small solo projects. Once accustomed to the powerful benefits of version control systems, many developers wouldn't consider working without it even for non-software projects.
** Team Work
*** centralized & distributed

* Git Introduction
** What is Git
[[https:/en.wikipedia.org][Git]] is a distributed version-control system for tracking changes in source code during software development. 
It is designed for coordinating work among programmers, but it can be used to track changes in any set of files. 
Its goals include speed, data integrity, and support for distributed, non-linear workflows.
Git is free and open-source software distributed under the terms of the GNU General Public License version 2.

*** Performance
*** Security
*** Flexibility

** History
Git was created by Linus Torvalds in 2005 for development of the Linux kernel, with other kernel developers contributing to its initial development. Its current maintainer since 2005 is Junio Hamano.

** Culture
** Installation of Git
*** Install Git on Mac OS X
There are several ways to install Git on a Mac. In fact, if you've installed XCode (or it's Command Line Tools), Git may already be installed. To find out, open a terminal and enter git --version.
#+BEGIN_SRC Sh
git --version
#+END_SRC

- Git for Mac Installer
  the latest [[https://sourceforge.net/projects/git-osx-installer/files/][Git for Mac installer]].
- Install Git with Homebrew
#+BEGIN_SRC sh
brew install git
#+END_SRC  
*** Install Git on Windows
The latest Git for [[https://gitforwindows.org/][Windows installe]].

*** Install Git on Linux
- Debian / Ubuntu
#+BEGIN_SRC sh
sudo apt-get update
sudo apt-get install git
#+END_SRC
*** Configure your Git username and email
Configure your Git username and email using the following commands, replacing "Your name" with your own. These details will be associated with any commits that you create:
#+BEGIN_SRC shell
git config --global user.name "Your name"
git config --global user.email "Your email address"
#+END_SRC

* Getting Started
** Basic settings 

$ git config --global user.name "Your Name"
$ git config --global user.email "youremail@example.com"

** Initialize a repository
- create a folder for testing
#+BEGIN_SRC shell
mkdir learngit
cd learngit
pwd 
#+END_SRC

- initialize a repository

#+BEGIN_SRC shell
git init
#+END_SRC
Initialized empty Git repository in /Users/ethanlin/Documents/ThingsEngine/ThingsEngine-Git/.git/

- add a file name readme.md
"Git is a version control system.
Git is free software." in readme.md

- add and commit

#+BEGIN_SRC shell
git add readme.txt

git commit -m "create a readme file"
#+END_SRC
[master (root-commit) eaadf4e] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 123456 readme.md

- add more files
#+BEGIN_SRC shell
touch file1.txt file2.txt file3.txt
#+END_SRC

#+BEGIN_SRC shell
git add file1.txt
git add file2.txt file3.txt
#+END_SRC

#+BEGIN_SRC shell
git commit -m "add 3 files"
#+END_SRC

- adjustment for readme.md
"Git is a distributed version control system.
Git is free software."

- git status

#+BEGIN_SRC shell
git status
#+END_SRC
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
 
	modified:   readme.txt
 
no changes added to commit (use "git add" and/or "git commit -a")

- git diff

#+BEGIN_SRC shell
git diff readme.md
#+END_SRC

diff --git a/readme.md b/readme.md
index 46d49bf..9247db6 100644
--- a/readme.md
+++ b/readme.md
@@ -1,2 +1,2 @@
-Git *is* a version control system.
+Git *is* a distributed version control system.
 Git *is* free software.

- update readme.md, new version

#+BEGIN_SRC shell
git add readme.md
#+END_SRC

#+BEGIN_SRC shell
git status
#+END_SRC
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
 
    modified:   readme.md

#+BEGIN_SRC shell
git commit -m "add distributed"
#+END_SRC
[master e475afc] add distributed
 1 file changed, 1 insertion(+), 1 deletion(-)

#+BEGIN_SRC 
$ git status
#+END_SRC
On branch master
nothing to commit, working tree clean
* Remote Repository at GitHub
#+BEGIN_SRC shell
ssh-keygen -t rsa -C "youremail@example.com"
#+END_SRC

You could find a directory .ssh in your home folder. id_rsa and *id_rsa.pub*

* Advanced Topic
** Branch Management
Compared with SVN, one of the specific features Git has is about branch. 

Teamwork in the real project development will benifit from the feature of branch. In this tutorial, the followings will be introduced:
- what is a branch
- The main branch operations
- how to achieve effective teamwork by through branch management

*** What is a branch
“A branch in Git is simply a lightweight movable pointer to one of these commits. The default branch name in Git is master. As you initially make commits, you're given a master branch that points to the last commit you made. Every time you commit, it moves forward automatically.”

*** Common operations of branches

- Creat a new branch based on the current branch
#+BEGIN_SRC shell
git branch develop
#+END_SRC

- Swith to the new branch
#+BEGIN_SRC shell
git checkout develop
#+END_SRC

- one step to create and switch to a new branch develop
#+BEGIN_SRC shell
git checkout -b develop
#+END_SRC
- Check the local branches
#+BEGIN_SRC shell
git branch
#+END_SRC

- Check the remot branches
#+BEGIN_SRC shell
git branch -r
#+END_SRC

Commit the readme.txt with add a new line:
"Creating a new branch is quick."
#+BEGIN_SRC 
$ git add readme.txt 
$ git commit -m "branch test"
[dev b17d20e] branch test
 1 file changed, 1 insertion(+)
#+END_SRC

- Push the created branch to github
#+BEGIN_SRC shell
git push origin develop
#+END_SRC

Then, switch to master branch

#+BEGIN_SRC 
$ git checkout master
Switched to branch 'master'
#+END_SRC

Then, merge what you have done in develop branch in to master branch: 

#+BEGIN_SRC 
$ git merge develop
Updating d46f35e..b17d20e
Fast-forward
 readme.txt | 1 +
 1 file changed, 1 insertion(+)
#+END_SRC

- Delete a local branch named develop
#+BEGIN_SRC shell
git branch -d develop
#+END_SRC

- Delete a remote branch named develop
#+BEGIN_SRC shell
git push origin :develop
#+END_SRC

- Fetch a remote branch to local
#+BEGIN_SRC shell
git checkout develop origin/develop
#+END_SRC

-  Fetch a remote branch to local and switch to this branch
#+BEGIN_SRC shell
git checkout -b develop origin/develop
#+END_SRC

*** Conflict resolution
Merge conflicts occur when competing changes are made to the same line of a file, or when one person edits a file and another person deletes the same file. For more information, see "[[https://help.github.com/en/articles/about-merge-conflicts/][About merge conflicts]]."


*Tip*: You can use the conflict editor on GitHub to resolve competing line change merge conflicts between branches that are part of a pull request. For more information, see "[[https://help.github.com/en/articles/resolving-a-merge-conflict-on-github][Resolving a merge conflict on GitHub.]]"

Create a new branch, such as feature_1. Then, 

#+BEGIN_SRC shell
$ git checkout -b feature_1
#+END_SRC
Switched to a new branch 'feature_1'

Adjust the last line of readme.md as: 

"Creating a *new* branch is quick *AND* simple."

Commit this file, readme.md in the feature_1 branch. 
#+BEGIN_SRC 
git add readme.md

git commit -m "AND simple"
#+END_SRC
[feature1 14096d0] AND simple
 1 file changed, 1 insertion(+), 1 deletion(-)

Switch to the master branch: 

#+BEGIN_SRC shell
$ git checkout master
#+END_SRC
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)

In the master branch, adjust the last line of readme.md as:
"Creating a *new* branch is quick & simple."

Then, commit it (readme.md in master branch)
#+BEGIN_SRC 
$ git add readme.txt 
$ git commit -m "& simple"
#+END_SRC
[master 5dc6824] & simple
 1 file changed, 1 insertion(+), 1 deletion(-)

There is a new commit in each of develop and master branches.
#+BEGIN_SRC shell
$ git merge feature1
#+END_SRC
Auto-merging readme.txt
CONFLICT (content): Merge conflict in readme.txt
Automatic merge failed; fix conflicts and then commit the result.

You can check the conflict by using git status: 
#+BEGIN_SRC shell
$ git status
On branch master
Your branch is ahead of 'origin/master' by 2 commits.
  (use "git push" to publish your local commits)

You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)

	both modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
#+END_SRC

We can check the readme.txt file, as the follows: 

#+BEGIN_SRC 
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
<<<<<<< HEAD
Creating a new branch is quick & simple.
=======
Creating a new branch is quick AND simple.
>>>>>>> feature1
#+END_SRC

Git uses <<<<<<<，=======，>>>>>>> to mark up the different contents in the different branches. 

Open your favorite text editor, such as Emacs, and navigate to the file that has merge conflicts. You can adjust the readme.md as: 

"Creating a new branch is quick and simple."

Then, use "git log" to show how the branch has been merged. 

#+BEGIN_SRC shell 
$ git log --graph --pretty=oneline --abbrev-commit
 *   cf810e4 (HEAD -> master) conflict fixed
|\  
| * 14096d0 (feature1) AND simple
 * | 5dc6824 & simple
|/  
 * b17d20e branch test
 * d46f35e (origin/master) remove test.txt
 * b84166e add test.txt
 * 519219b git tracks changes
 * e43a48b understand how stage works
 * 1094adb append GPL
 * e475afc add distributed
 * eaadf4e wrote a readme file
#+END_SRC

In the final step, you can delete the feature_1 branch. 

#+BEGIN_SRC shell
$ git branch -d feature1
Deleted branch feature1 (was 14096d0).
#+END_SRC
*** TODO Merge with a new commit
When to merge from another branch, the git system normally uses "fast-forward" mode. Under this mode, once the branch is delete, the info of the branch will be also deleted. 

This "fast forward" mode can be forced to be off, then, a new commit will be generated to record the info. of branch. 

See the following practice using "git merge" with "--no-ff"
#+BEGIN_SRC emacs lisp
$ git checkout -b dev
Switched to a new branch 'dev'
#+END_SRC

Adjust readme.txt, and commit it. 
#+BEGIN_SRC shell
$ git add readme.txt 
$ git commit -m "add merge"
[dev f52c633] add merge
 1 file changed, 1 insertion(+)
#+END_SRC

Then, switch to master: 
#+BEGIN_SRC shell
$ git checkout master
Switched to branch 'master'
#+END_SRC

Merge the develop branch with "--no-ff" to prevent using the fast forward mode. 
#+BEGIN_SRC shell
$ git merge --no-ff -m "merge with no-ff" dev
Merge made by the 'recursive' strategy.
 readme.txt | 1 +
 1 file changed, 1 insertion(+)
#+END_SRC

In this merge, a new commit was created and can be checked by "git log":
#+BEGIN_SRC shell
$ git log --graph --pretty=oneline --abbrev-commit
*   e1e9c68 (HEAD -> master) merge with no-ff
|\  
| * f52c633 (dev) add merge
|/  
*   cf810e4 conflict fixed
...
#+END_SRC

This is the case how to merge without the fast forward mode. 

*** Branch Management Strategy
[[file:git-model.png][A successful Git branching model]]
In real application development, we should follow the following basic rules to achieve branch management: 
1. The master branch should be used for new version release;
2. Developing activities on the develop branch
3. Each user has it own branch. 

So, a teamwork looks like the following diagram: 
[[file:teamwork_strategy.png][Teamwork Branch Management Strategy]]
*** TODO the branch of bugs
   SCHEDULED: <2019-10-01 Tue 13:30>
*** TODO the branch of features
   SCHEDULED: <2019-10-01 Tue 13:30>
** Bookmark Management
** Customization
* Magit Tutorial
** Basic magit
*** Create a git repo
  [[info:magit#Repository%20setup][info:magit#Repository setup]]
  You can create a git repo with M-x magit-init. This will create a git-repo in the current directory.

  #+BEGIN_SRC emacs-lisp
 (magit-init)
  #+END_SRC

  help:magit-init

*** Clone a repo
  [[info:magit#Repository%20setup][info:magit#Repository setup]]

  M-x magit-clone

  This will prompt you for a repo, which is either a url, or a path, and a path to clone it to.

  help:magit-clone

*** Check the status of your repo
  [[info:magit#Status%20buffer][info:magit#Status buffer]]

  Run M-x magit-status to see the status of your repo.

  Press "g" in the window to refresh it.

  press "n" (next) or "p" (previous) to navigate in this window.

  help:magit-status

*** Stage a file
  [[info:magit#Staging%20and%20unstaging][info:magit#Staging and unstaging]]

  In the magit-status window, put your cursor on an unstaged file and press "s".

  If you press TAB on the file, it will expand to show the changes that are unstaged. Deletions show in red, and additions in green. The changes are in "hunks".

  You can unstage a file with "u"

*** Commit a file
  [[info:magit#Initiating%20a%20commit][info:magit#Initiating a commit]]

  [[info:magit#Editing%20commit%20messages][info:magit#Editing commit messages]]

  In the magit-status window with some files that are staged, press "c", review the options, and probably press "c" again. Enter a commit message and type "C-c C-c" to commit it, or "C-c C-k" to cancel it.

*** Diffs
  [[info:magit#Diffing][info:magit#Diffing]]

  From the magit-status window, press "d" then "d" to see what has changed.

*** See the log
  [[info:magit#Logging][info:magit#Logging]]

  In the magit-status window press "l", review the options, and press "l" again.

  If you want to see only the commits that affected a file, in the magit-status window press "l" then "=f", enter the filename, and then press "l" again.

*** Push
  [[info:magit#Pushing][info:magit#Pushing]]

  In the magit-status window press "P" then "p".

  Note that tags don't normally get pushed, but there are options ("T" to push a tag, and "t" to push all tags).

*** Pull
  [[info:magit#Pulling][info:magit#Pulling]]
  In the magit-status window press "F" then "p".

*** Run a command-line git command manually
  [[info:magit#Running%20Git%20manually][info:magit#Running Git manually]]
  In the magit-status window, type "!" to get the popup and choose what you want to do (e.g. where to run the command, etc... You do not need to type "git" in the command. Note you can also run a shell command from this interface.

*** Check the output of the git command
  Press "$"

*** Keybindings
  [[info:magit#Keystroke%20Index][info:magit#Keystroke Index]]
** Intermediate concepts
*** Checkout an older version of a file
  Use M-x magit-checkout-file select the branch, or enter a revision, and then choose a file.

 help:magit-checkout-file 

 help:magit-find-file
 help:magit-find-file-other-window

*** Search the commit messages for a pattern
 In a magit-status window press "l =g" enter a pattern to grep for, and then press "l".
*** Revert a commit
 [[info:magit#Reverting][info:magit#Reverting]]

  Got to the log, select the commit and type "V" then "V".
*** Tag a version
  [[info:magit#Tagging][info:magit#Tagging]]

  press "t" in the magit-status window. You can then create a tag, annotate it, delete tags, and prune them.
*** Checkout an existing branch.
  [[info:magit#The%20branch%20popup][info:magit#The branch popup]]

  In the magit-status window press "b" then "b" and choose the branch.

  To checkout a new branch, in the magit-status window press "b" then "c". Choose the branch to start from then a name for the new branch.

*** Merge two branches
  [[info:magit#Merging][info:magit#Merging]]

  In the magit-status window press "m", then "m" and select the branch to merge into the current one.
*** TODO Resolving conflicts
 [[info:magit#Resolving%20conflicts][info:magit#Resolving conflicts]]

 You will probably also want to get familiar with [[info:ediff#Top][info:ediff#Top]].

 On a file in a magit-status window, press "e" to enter the 3-window ediff view. The A window is the version at HEAD, the B window is what is in the index, and the C window is the current version.

*** Fetching
 [[info:magit#Fetching][info:magit#Fetching]]

 In the magit-status window press "f".

*** Add a remote
  [[info:magit#Remotes][info:magit#Remotes]]

  M-x magit-remote-add
  then enter an alias, and the url.

*** Stashing
 [[info:magit#Stashing][info:magit#Stashing]]

 Press "z" in the magit-status window
*** Git blame
** Advanced concepts
*** Resetting
 [[info:magit#Resetting][info:magit#Resetting]]

*** Rebasing 
  [[info:magit#Rebasing][info:magit#Rebasing]]

**** Interactve rebasing
  Open the log, select the oldest commit you want to rebase on then press "r" and then "i". Use M-p and M-n to move commits around. Press "s" on any commits you want to squash into the commit above it. C-c C-c will start the commands.

  From the magit-status on unpushed commits, you can also press "r" to get the rebase popup.

**** Reword a commit message
  "r w" allows you to reword the commit message.

*** Create patches
  [[info:magit#Creating%20and%20sending%20patches][info:magit#Creating and sending patches]]

  In magit-status window, press "W"

  "W p" creates patches
  "W r" makes a pull request. This just creates an email with information in it. It is not a GitHUB request, and it is only useful if there is a public, external copy of the repo.
*** Cherry-picking 
 [[info:magit#Cherry%20picking][info:magit#Cherry picking]]

 Press "A"

*** Apply patches
  [[info:magit#Applying%20patches][info:magit#Applying patches]]

*** Notes about commits
  [[info:magit#Notes][info:magit#Notes]]

  Press "T" to attach a note.

  A typical use of notes is to supplement a commit message without changing the
	  commit itself. Notes can be shown by git log along with the original
	  commit message. To distinguish these notes from the message stored in
	  the commit object, the notes are indented like the message, after an
	  unindented line saying "Notes (<refname>):" (or "Notes:" for
	  refs/notes/commits).

*** Cherry-picking 
 [[info:magit#Cherry%20picking][info:magit#Cherry picking]]

* TODO Test
  DEADLINE: <2019-08-13 Tue 19:00>
<2019-08-13 Tue 18:00>

This is a test

:ANSWER:
This is a test drawer
:END:

:Ans:
This is a test two
:END
